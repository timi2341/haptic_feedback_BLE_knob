#include <Arduino.h>
#include <Wire.h>
#include <SimpleFOC.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


// 'knob menu', 128x64px
const unsigned char epd_bitmap_knob_menu [] PROGMEM = {
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc2, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 
	0x40, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x40, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x40, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0x0c, 0x00, 0xf0, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x40, 0x18, 0x01, 0x98, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0x30, 0x01, 0x99, 0xf0, 0xf8, 0xc3, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x40, 0x60, 0x01, 0x99, 0x99, 0x98, 0xc6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0xc0, 0x01, 0x99, 0x99, 0x98, 0xc6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x41, 0x80, 0x01, 0xf9, 0x99, 0x98, 0xc7, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x43, 0x40, 0x01, 0x99, 0x99, 0x98, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x46, 0x20, 0x01, 0x99, 0x98, 0xf8, 0xc6, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x4e, 0x20, 0x01, 0x99, 0x98, 0x18, 0x63, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x4f, 0xff, 0xf0, 0x00, 0x01, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 
	0x40, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 
	0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x21, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x21, 0x10, 0x02, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x21, 0x11, 0xc7, 0x8e, 0x3c, 0x78, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x08, 0x21, 0x12, 0x22, 0x11, 0x22, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x08, 0x21, 0x12, 0x22, 0x11, 0x22, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x28, 0xa1, 0x13, 0xe2, 0x1f, 0x22, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xaa, 0xa1, 0x12, 0x02, 0x10, 0x22, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x02, 0xaa, 0xa1, 0x12, 0x22, 0x11, 0x22, 0x21, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0a, 0xaa, 0xa1, 0xe1, 0xc1, 0x8e, 0x22, 0x18, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x0a, 0xaa, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x1e, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x21, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0x0f, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x21, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x21, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x21, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x21, 0x08, 0x43, 0x80, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x21, 0x08, 0x44, 0x44, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x21, 0x08, 0x44, 0x0f, 0x26, 0x38, 0xf0, 0xf3, 0xcf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x21, 0x08, 0x44, 0x04, 0x28, 0x44, 0x89, 0x11, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x21, 0x08, 0x43, 0x84, 0x30, 0x44, 0x89, 0x11, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x20, 0xf0, 0x40, 0x44, 0x20, 0x7c, 0x89, 0x11, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x20, 0x00, 0x40, 0x44, 0x20, 0x40, 0x89, 0x11, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x10, 0x00, 0x84, 0x44, 0x20, 0x44, 0x88, 0xf1, 0x08, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x01, 0x03, 0x83, 0x20, 0x38, 0x88, 0x10, 0xc8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x07, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define OLED_ADDR 0x3C
#define I2C_SDA 1
#define I2C_SCL 2
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

MagneticSensorI2C sensor = MagneticSensorI2C(AS5600_I2C);
BLDCMotor motor = BLDCMotor(7);
BLDCDriver3PWM driver = BLDCDriver3PWM(5, 6, 7, 4);

float right_limit = 6.14;
float left_limit = 3.0;

float num_detents = 80;
float vel_p_value = 1.0f;
float vel_p_value_in_limits = 0.45f;
float vel_i_value = 0.0f;
float vel_d_value = 0.001f;
float pos_p_value = 30.0f;
float tf_value = 4.0f;
float threshold = 0.0f;

// instantiate the commander
Commander command = Commander(Serial);

void changeNumOfDetents(char* cmd) {
  command.scalar(&num_detents, cmd);
  Serial.println("Changed num of detents");
}
void changePVal(char* cmd) {
  command.scalar(&vel_p_value, cmd);
  Serial.println("changed P Parameter");
}
void changeIVal(char* cmd) {
  command.scalar(&vel_i_value, cmd);
  Serial.println("changed I Parameter");
}
void changeDVal(char* cmd) {
  command.scalar(&vel_d_value, cmd);
  Serial.println("changed D Parameter");
}
void changePosPVal(char* cmd) {
  command.scalar(&pos_p_value, cmd);
  Serial.println("changed POS P Parameter");
}
void changeFVal(char* cmd) {
  command.scalar(&tf_value, cmd);
  Serial.println("changed Time filter constant");
}
void changeTh(char* cmd) {
  command.scalar(&threshold, cmd);
  Serial.println("changed threshold");
}
void changePLVal(char* cmd) {
  command.scalar(&vel_p_value_in_limits, cmd);
  Serial.println("changed P Within Limits Parameter");
}
void setup() {
  Serial.begin(115200);
  SimpleFOCDebug::enable(&Serial);
  Wire.begin(1, 2,400000);
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { 
    Serial.println("SSD1306 allocation failed");
    for (;;);
  }

  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);
  display.setTextSize(1);
  display.clearDisplay();

  // Draw your bitmap
  display.drawBitmap(
    0, 0,        // x,y position on screen
    epd_bitmap_knob_menu,      // bitmap array
    128, 64,        // width, height
    SSD1306_WHITE
  );
  display.setCursor(0, 0);
  display.display();
  sensor.init();
  motor.linkSensor(&sensor);
  driver.voltage_power_supply = 12;
  driver.init();
  motor.linkDriver(&driver);
  motor.foc_modulation = FOCModulationType::SpaceVectorPWM;
  motor.controller = MotionControlType::angle;
  motor.velocity_limit = 3;
  motor.useMonitoring(Serial);
  motor.init();
  // align sensor and start FOC
  motor.initFOC();

  // add target command T
  command.add('s', changePosPVal, "POS P Value");
  command.add('t', changeNumOfDetents, "Number of detents");
  command.add('p', changePVal, "P Value");
  command.add('o', changePLVal, "P Value within limits");
  command.add('i', changeIVal, "I Value");
  command.add('d', changeDVal, "D Value");
  command.add('f', changeFVal, "Tf Value");
  command.add('h', changeTh, "Threshold Value");

  Serial.println(F("Motor ready."));
  _delay(1000);
}


void loop() {

  motor.PID_velocity.I = vel_i_value;
  motor.PID_velocity.D = vel_d_value;
  motor.LPF_velocity.Tf = tf_value;
  float motor_angle=motor.shaftAngle();
  float nearest_angle = motor_angle; 
  
  // Guard clause for N=1 (Start only) or invalid inputs
  if (num_detents <= 1) {
    nearest_angle = left_limit;
  } 
  else {
    // 1. Calculate the full range of motion
    float range = right_limit - left_limit;
    
    // 2. Calculate the step size (radians per detent)
    // We divide by (num_detents - 1) because 2 detents = 1 gap, 3 detents = 2 gaps, etc.
    float step_size = range / (float)(num_detents - 1);
    
    // 3. Calculate how many steps we are away from the left limit
    // We use round() to snap to the closest integer step
    float current_step = round((motor_angle - left_limit) / step_size);
    
    // 4. Calculate the ideal angle for that step
    nearest_angle = left_limit + (current_step * step_size);
  }
  bool past_limit = false;
  if (nearest_angle < left_limit - threshold) {
    nearest_angle = left_limit;
    past_limit = true;
  }
  if (nearest_angle > right_limit + threshold) {
    nearest_angle = right_limit;
    past_limit = true;
  }
  if (!past_limit) {
    motor.PID_velocity.P = vel_p_value_in_limits; 
    motor.P_angle.P = pos_p_value;
  } else {
    motor.PID_velocity.P = vel_p_value;
    motor.P_angle.P = pos_p_value;
  }

  motor.loopFOC();


  motor.move(nearest_angle);
  command.run();
}